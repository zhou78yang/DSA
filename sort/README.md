#排序算法

### [冒泡排序](./bubble_sort.h)                                                                 

冒泡排序（Bubble sort）是最基本的一种排序算法。                                                                                 
*它的基本思想是：*                        
通过一趟排序将要排序的数据集Ｖ分成两部分Ｕ（待排部分）和Ｓ（有序部分），在一趟对Ｕ的扫描交换中，每一次比对都会检测逆序，如发现逆序，则两元素交换以消除逆序。在一趟扫描交换之后，Ｕ中最大的元素就会被移到Ｕ的末尾，此时将Ｕ的最后一个元素移到Ｓ中。则每一趟扫描交换后，Ｕ的长度都会递减，而Ｓ的长度都会递增，最终达到整体有序.

### [归并排序](./merge_sort.h)                                                                  

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。通常情况下我们说的归并都是值二路归并。                                                                   
*它的基本思想是：*                                                                                          
归并排序的过程可以分为两部分，第一部分对应于递归的深入，不断均匀地划分子段，直到其规模缩小为递归基；第二部分则对应着递归返回，通过归并使得两段子段合成有序的一段序列。最终实现整个数据段的有序.

### [快速排序](./quick_sort.h)                                                                  

快速排序（Quick sort）                                                                  
*它的基本思想是：*                                                                                          
通过轴点构造算法partition，每次获取一个轴点ｖ（通常是数据段的第一个元素），然后对数据段进行一次扫描，将比ｖ小的元素插入倒ｖ的前方，而将比ｖ大的元素保留在ｖ的后方，每趟扫描后将数据段分成３个部分：左边Ｌ中的每一个元素都会比ｖ小，ｖ，右边Ｒ中的每一个元素都不会比ｖ小。然后使用递归再分别对Ｌ和Ｒ进行排序。　　　　　　　　　
*可以发现，每次partition执行完后v都将处于最终整个列表有序时它所在的位置*
快速排序和归并排序一样，也是分治算法的一种典型应用。但是两者又有很大的不同，归并排序中每次仅需O(1)的时间来进行分段，在归并的时候消耗O(n)的时间，主要消耗在归并的操作上；而快速排序中对于每个子段的处理仅需O(1)的时间，而却需要花费O(n)的时间来进行分段，主要消耗在于分段。

### [选择排序](./selection_sort.h)

选择排序（Selection sort）是一种简单直观的排序算法。                               
它将要排序的数据集Ｖ分成两部分Ｕ（待排部分）和Ｓ（有序部分），每次扫描一趟Ｕ都会找出Ｕ中的最大值ｍ，然后将ｍ插入到Ｓ的首元素前，然后Ｕ收缩，Ｓ扩增。可以看出，冒泡排序实际上就是一种选择排序，但冒泡排序是通过一种“小踏步”的形式将ｍ最终移到Ｕ的末端，需要进行多次交换，而选择排序仅需进行一次交换，两者的时间复杂度虽然都是O(n^2)，但选择排序对于交换的消耗却要小很多。

### [插入排序](./insert_sort.h)

插入排序(Insertion sort)也是将要排序的数据集Ｖ分成两部分Ｓ（有序部分）和Ｕ（待排部分），但与选择排序不同的是，插入排序要扫描的对象是Ｓ，即每次取出Ｕ中的第一个元素ｅ，查找ｅ在Ｓ中的应处于的位置，然后将ｅ插入到Ｓ中，每次Ｓ都会扩增，而Ｕ都会收缩。通常插入排序应用于[List](../list)中，因为在顺序表中可以通过搜索算法快速地找到ｅ应该插入的位置，但是顺序表的插入操作却仍然需要消耗O(n)的时间，而List的查找操作消耗O(n)的时间，但是插入仅需O(1)的操作.

### [堆排序](./heap_sort.h)

堆排序(Heap sort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。

